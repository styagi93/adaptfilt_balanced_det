//`timescale 20 ns / 0.01 ns
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module a2dv2(

	//////////// CLOCK //////////
	CLOCK_50,
	CLOCK2_50,
	CLOCK3_50,

	//////////// LED //////////
	LEDG,
	LEDR,

	//////////// KEY //////////
	KEY,

	//////////// SW //////////
	SW,

	//////////// SEG7 //////////
	HEX0,
	HEX1,
	HEX2,
	HEX3,
	HEX4,
	HEX5,
	HEX6,
	HEX7,

	//////////// LCD //////////
	LCD_BLON,
	LCD_DATA,
	LCD_EN,
	LCD_ON,
	LCD_RS,
	LCD_RW,

	//////////// SDCARD //////////
	SD_CLK,
	SD_CMD,
	SD_DAT,
	SD_WP_N,

	//////////// I2C for HSMC  //////////
	I2C_SCLK,
	I2C_SDAT,

	//////////// Flash //////////
	FL_ADDR,
	FL_CE_N,
	FL_DQ,
	FL_OE_N,
	FL_RST_N,
	FL_RY,
	FL_WE_N,
	FL_WP_N,

	//////////// HSMC, HSMC connect to DCC - High Speed ADC/DAC //////////
	AD_SCLK,
	AD_SDIO,
	ADA_D,
	ADA_DCO,
	ADA_OE,
	ADA_OR,
	ADA_SPI_CS,
	ADB_D,
	ADB_DCO,
	ADB_OE,
	ADB_OR,
	ADB_SPI_CS,
	AIC_BCLK,
	AIC_DIN,
	AIC_DOUT,
	AIC_LRCIN,
	AIC_LRCOUT,
	AIC_SPI_CS,
	AIC_XCLK,
	CLKIN1,
	CLKOUT0,
	DA,
	DB,
	FPGA_CLK_A_N,
	FPGA_CLK_A_P,
	FPGA_CLK_B_N,
	FPGA_CLK_B_P,
	J1_152,
	XT_IN_N,
	XT_IN_P,
	NCO_OUT,
	clk_1khz,
	ast_source_data,
	ast_source_valid,
	ast_source_error
);

//=======================================================
//  PARAMETER declarations
//=======================================================


//=======================================================
//  PORT declarations
//=======================================================

//////////// CLOCK //////////
input 		          		CLOCK_50;
input 		          		CLOCK2_50;
input 		          		CLOCK3_50;

//////////// LED //////////
output		     [8:0]		LEDG;
output		    [17:0]		LEDR;

//////////// KEY //////////
input 		     [3:0]		KEY;

//////////// SW //////////
input 		    [17:0]		SW;

//////////// SEG7 //////////
output		     [6:0]		HEX0;
output		     [6:0]		HEX1;
output		     [6:0]		HEX2;
output		     [6:0]		HEX3;
output		     [6:0]		HEX4;
output		     [6:0]		HEX5;
output		     [6:0]		HEX6;
output		     [6:0]		HEX7;

//////////// LCD //////////
output		          		LCD_BLON;
inout 		     [7:0]		LCD_DATA;
output		          		LCD_EN;
output		          		LCD_ON;
output		          		LCD_RS;
output		          		LCD_RW;

//////////// SDCARD //////////
output		          		SD_CLK;
inout 		          		SD_CMD;
inout 		     [3:0]		SD_DAT;
input 		          		SD_WP_N;

//////////// I2C for HSMC  //////////
output		          		I2C_SCLK;
inout 		          		I2C_SDAT;

//////////// Flash //////////
output		    [22:0]		FL_ADDR;
output		          		FL_CE_N;
inout 		     [7:0]		FL_DQ;
output		          		FL_OE_N;
output		          		FL_RST_N;
input 		          		FL_RY;
output		          		FL_WE_N;
output		          		FL_WP_N;

//////////// HSMC, HSMC connect to DCC - High Speed ADC/DAC //////////
inout 		          		AD_SCLK;
inout 		          		AD_SDIO;
input 		    [13:0]		ADA_D;
input 		          		ADA_DCO;
output		          		ADA_OE;
input 		          		ADA_OR;
output		          		ADA_SPI_CS;
input 		    [13:0]		ADB_D;
input 		          		ADB_DCO;
output		          		ADB_OE;
input 		          		ADB_OR;
output		          		ADB_SPI_CS;
inout 		          		AIC_BCLK;
output		          		AIC_DIN;
input 		          		AIC_DOUT;
inout 		          		AIC_LRCIN;
inout 		          		AIC_LRCOUT;
output		          		AIC_SPI_CS;
output		          		AIC_XCLK;
input 		          		CLKIN1;
output		          		CLKOUT0;
output		    [13:0]		DA;
output		    [13:0]		DB;
inout 		          		FPGA_CLK_A_N;
inout 		          		FPGA_CLK_A_P;
inout 		          		FPGA_CLK_B_N;
inout 		          		FPGA_CLK_B_P;
inout 		          		J1_152;
input 		          		XT_IN_N;
input 		          		XT_IN_P;


//=======================================================
//  REG/WIRE declarations
//=======================================================

wire						reset_n;
wire						sys_clk;
reg			[13:0]	per_a2da_d;
reg			[13:0]	a2da_data;

//////////// NCO //////////

output reg clk_1khz=0;
reg [15:0] counter = 16'd0;
output [11:0] NCO_OUT;
wire NCO_FREQ_UP;
wire NCO_FREQ_DOWN;
wire filter_change_sw;
reg [11:0] NCO_OUT;
integer temp = 20'b00000000000000000001;
wire [19:0] NCO_IN;
assign NCO_IN =temp;
assign	filter_change_sw	= SW[17];	


//////////// FIR //////////


wire [1:0]  ast_sink_error = 2'b00;
output  [32:0] ast_source_data;
output         ast_source_valid;
output  [1:0]  ast_source_error;
wire [4:0]  coeff_in_address;
wire        coeff_in_areset=1'b0;
wire        coeff_in_read = 1'b0;
wire [0:0]  coeff_out_valid;
wire [15:0] coeff_out_data;
wire [0:0]  coeff_in_we=1'b0;
wire [15:0] coeff_in_data;
reg [15:0] mem [0:31] = '{-16'sd1, 16'sd63, -16'sd89, 16'sd3, 16'sd227, -16'sd435, 16'sd301, 16'sd349, -16'sd1202, 16'sd1430, -16'sd247, -16'sd2235, 16'sd4504, -16'sd3920, -16'sd3006, 16'sd32767, 16'sd32767, -16'sd3006, -16'sd3920, 16'sd4504, -16'sd2235, -16'sd247, 16'sd1430, -16'sd1202, 16'sd349, 16'sd301, -16'sd435, 16'sd227, 16'sd3, -16'sd89, 16'sd63, -16'sd1};
reg [15:0] mem1 [0:31] = '{16'sd309, -16'sd226, -16'sd47, -16'sd349, -16'sd1037, 16'sd1932, 16'sd2737, -16'sd2959, -16'sd2021,-16'sd556, -16'sd4962, 16'sd10950, 16'sd17813, -16'sd24493, -16'sd29815, 16'sd32767, 16'sd32767,-16'sd29815, -16'sd24493, 16'sd17813, 16'sd10950, -16'sd4962, -16'sd556, -16'sd2021, -16'sd2959, 16'sd2737, 16'sd1932, -16'sd1037, -16'sd349, -16'sd47, -16'sd226, 16'sd309};
integer switch_prev= 0;
integer i = 0;

//=======================================================
//  Structural coding
//=======================================================

//--- globa signal assign
assign	reset_n			= KEY[3];
assign	NCO_FREQ_UP			= KEY[2];
assign	NCO_FREQ_DOWN			= KEY[1];
assign	FPGA_CLK_A_P	=  sys_clk;
assign	FPGA_CLK_A_N	= ~sys_clk;

 // assign for ADC control signal
assign	AD_SCLK			= SW[0];			// (DFS)Data Format Select
assign	AD_SDIO			= SW[1];			// (DCS)Duty Cycle Stabilizer Select
assign	ADA_OE			= 1'b0;				// enable ADA output
assign	ADA_SPI_CS		= 1'b1;				// disable ADA_SPI_CS (CSB)


//--- analog to digital converter capture and sync
	//--- Channel A
always @(negedge reset_n or posedge ADA_DCO)
begin
	if (!reset_n) begin
		per_a2da_d	<= 14'd0;
	end
	else begin
		per_a2da_d	<= ADA_D;
	end
end

always @(negedge reset_n or posedge sys_clk)
begin
	if (!reset_n) begin
		a2da_data	<= 14'd0;
	end
	else begin
		a2da_data	<= per_a2da_d;
	end
end


//--- probe points for data capture
a2d_data_a	a2d_data_a_inst(
			.probe(a2da_data),
			.source());

nco abc_inst (.clk			(CLOCK_50),
			.phase_incr (NCO_IN),
			.cos_out  (NCO_OUT));
	
always @(posedge CLOCK_50)
begin
	if (counter == 16'd2500)
	begin
	clk_1khz <= ~clk_1khz;
	counter <= 16'd0;
	end
	else 
	begin
	counter = counter +1;	
	end	
end

always @( posedge clk_1khz)
begin
	if ((NCO_FREQ_UP ==1) && (NCO_FREQ_DOWN ==0))
	begin 
	temp= temp + 1;
	end
	
	if ((NCO_FREQ_DOWN ==1) && (NCO_FREQ_UP ==0))
	begin 
	temp= temp - 1;
	end
end 

/*
fir_IP_0002 fir_ip_inst (
		.clk              (CLOCK_50),              //                     clk.clk
		.reset_n          (reset_n),          //                     rst.reset_n
		.ast_sink_data    (NCO_OUT),    //   avalon_streaming_sink.data
		.ast_sink_valid   (1'b1),   //                        .valid
		.ast_sink_error   (ast_sink_error),   //                        .error
		.ast_source_data  (ast_source_data),  // avalon_streaming_source.data
		.ast_source_valid (ast_source_valid), //                        .valid
		.ast_source_error (ast_source_error)  //                        .error
	);
*/
	
	fir_IP_0002 fir_ip_inst (
		.clk              (CLOCK_50),              //                     clk.clk
		.reset_n          (reset_n),          //                     rst.reset_n
		.ast_sink_data    (NCO_OUT),    //   avalon_streaming_sink.data
		.ast_sink_valid   (1'b1),   //                        .valid
		.ast_sink_error   (ast_sink_error),   //                        .error
		.ast_source_data  (ast_source_data),  // avalon_streaming_source.data
		.ast_source_valid (ast_source_valid), //                        .valid
		.ast_source_error (ast_source_error),
		//                        .error
		.coeff_in_clk     (CLOCK_50),     //             coeff_clock.clk
		.coeff_in_areset  (coeff_in_areset),  //             coeff_reset.reset_n
		.coeff_in_address (coeff_in_address), //         avalon_mm_slave.address
		.coeff_in_read    (coeff_in_read),    //                        .read
		.coeff_out_valid  (coeff_out_valid),  //                        .readdatavalid
		.coeff_out_data   (coeff_out_data),   //                        .readdata
		.coeff_in_we      (coeff_in_we),      //                        .write
		.coeff_in_data    (coeff_in_data)     //                        .writedata
	);

	
always @ (posedge CLOCK_50)
begin 
	if ((filter_change_sw ==1) && (switch_prev ==0))
	begin
	coeff_in_areset =1'b1;
	switch_prev =1;
	coeff_in_areset = 1'b0;
	for (i=0; i<32 ; i=i+1)
	begin
		coeff_in_we <= 1'b1;
		coeff_in_address <= i;
		coeff_in_data <= mem[i];
		
	end
	coeff_in_we <= 1'b0;
	end

	if ((filter_change_sw ==0) && (switch_prev ==1))
	begin
	coeff_in_areset =1'b1;
	switch_prev =0;
	coeff_in_areset = 1'b0;
	for (i=0; i<32 ; i=i+1)
	begin
		coeff_in_we <= 1'b1;
		coeff_in_address <= i;
		coeff_in_data <= mem1[i];
		
	end
	coeff_in_we <= 1'b0;
	end
end	

endmodule
