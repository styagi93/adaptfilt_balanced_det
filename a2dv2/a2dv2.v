//`timescale 20 ns / 0.01 ns
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module a2dv2(

	//////////// CLOCK //////////
	CLOCK_50,
	CLOCK2_50,
	CLOCK3_50,

	//////////// LED //////////
	LEDG,
	LEDR,

	//////////// KEY //////////
	KEY,

	//////////// SW //////////
	SW,

	//////////// SEG7 //////////
	HEX0,
	HEX1,
	HEX2,
	HEX3,
	HEX4,
	HEX5,
	HEX6,
	HEX7,

	//////////// LCD //////////
	LCD_BLON,
	LCD_DATA,
	LCD_EN,
	LCD_ON,
	LCD_RS,
	LCD_RW,

	//////////// SDCARD //////////
	SD_CLK,
	SD_CMD,
	SD_DAT,
	SD_WP_N,

	//////////// I2C for HSMC  //////////
	I2C_SCLK,
	I2C_SDAT,

	//////////// Flash //////////
	FL_ADDR,
	FL_CE_N,
	FL_DQ,
	FL_OE_N,
	FL_RST_N,
	FL_RY,
	FL_WE_N,
	FL_WP_N,

	//////////// HSMC, HSMC connect to DCC - High Speed ADC/DAC //////////
	AD_SCLK,
	AD_SDIO,
	ADA_D,
	ADA_DCO,
	ADA_OE,
	ADA_OR,
	ADA_SPI_CS,
	ADB_D,
	ADB_DCO,
	ADB_OE,
	ADB_OR,
	ADB_SPI_CS,
	AIC_BCLK,
	AIC_DIN,
	AIC_DOUT,
	AIC_LRCIN,
	AIC_LRCOUT,
	AIC_SPI_CS,
	AIC_XCLK,
	CLKIN1,
	CLKOUT0,
	DA,
	DB,
	FPGA_CLK_A_N,
	FPGA_CLK_A_P,
	FPGA_CLK_B_N,
	FPGA_CLK_B_P,
	J1_152,
	XT_IN_N,
	XT_IN_P,
	NCO_OUT,
	clk_1khz,
	ast_source_data,
	ast_source_valid,
	ast_source_error,
	DFF_ast_source_data,
	CLOCK_200	
);

//=======================================================
//  PARAMETER declarations
//=======================================================


//=======================================================
//  PORT declarations
//=======================================================

//////////// CLOCK //////////
input 		          		CLOCK_50;
input 		          		CLOCK2_50;
input 		          		CLOCK3_50;

//////////// LED //////////
output		     [8:0]		LEDG;
output		    [17:0]		LEDR;

//////////// KEY //////////
input 		     [3:0]		KEY;

//////////// SW //////////
input 		    [17:0]		SW;

//////////// SEG7 //////////
output		     [6:0]		HEX0;
output		     [6:0]		HEX1;
output		     [6:0]		HEX2;
output		     [6:0]		HEX3;
output		     [6:0]		HEX4;
output		     [6:0]		HEX5;
output		     [6:0]		HEX6;
output		     [6:0]		HEX7;

//////////// LCD //////////
output		          		LCD_BLON;
inout 		     [7:0]		LCD_DATA;
output		          		LCD_EN;
output		          		LCD_ON;
output		          		LCD_RS;
output		          		LCD_RW;

//////////// SDCARD //////////
output		          		SD_CLK;
inout 		          		SD_CMD;
inout 		     [3:0]		SD_DAT;
input 		          		SD_WP_N;

//////////// I2C for HSMC  //////////
output		          		I2C_SCLK;
inout 		          		I2C_SDAT;

//////////// Flash //////////
output		    [22:0]		FL_ADDR;
output		          		FL_CE_N;
inout 		     [7:0]		FL_DQ;
output		          		FL_OE_N;
output		          		FL_RST_N;
input 		          		FL_RY;
output		          		FL_WE_N;
output		          		FL_WP_N;

//////////// HSMC, HSMC connect to DCC - High Speed ADC/DAC //////////
inout 		          		AD_SCLK;
inout 		          		AD_SDIO;
input 		    [13:0]		ADA_D;
input 		          		ADA_DCO;
output		          		ADA_OE;
input 		          		ADA_OR;
output		          		ADA_SPI_CS;
input 		    [13:0]		ADB_D;
input 		          		ADB_DCO;
output		          		ADB_OE;
input 		          		ADB_OR;
output		          		ADB_SPI_CS;
inout 		          		AIC_BCLK;
output		          		AIC_DIN;
input 		          		AIC_DOUT;
inout 		          		AIC_LRCIN;
inout 		          		AIC_LRCOUT;
output		          		AIC_SPI_CS;
output		          		AIC_XCLK;
input 		          		CLKIN1;
output		          		CLKOUT0;
output		    [13:0]		DA;
output		    [13:0]		DB;
inout 		          		FPGA_CLK_A_N;
inout 		          		FPGA_CLK_A_P;
inout 		          		FPGA_CLK_B_N;
inout 		          		FPGA_CLK_B_P;
inout 		          		J1_152;
input 		          		XT_IN_N;
input 		          		XT_IN_P;


//=======================================================
//  REG/WIRE declarations
//=======================================================

wire						reset_n;
wire						sys_clk;
reg			[13:0]	per_a2da_d;
reg			[13:0]	a2da_data;

//////////// NCO //////////

output reg clk_1khz=0;
output CLOCK_200;
reg [15:0] counter = 16'd0;
reg [5:0] async_counter= 6'd0;
output reg [11:0] NCO_OUT;
reg [11:0] l_NCO_OUT;
wire NCO_FREQ_UP;
wire NCO_FREQ_DOWN;
wire filter_change_sw;
integer temp = 20'b00000000000000000001;
wire [19:0] NCO_IN;
assign NCO_IN =temp;
assign	filter_change_sw	= SW[17];	
reg l_CLOCK_50;
reg ll_CLOCK_50;
reg lll_CLOCK_50;


//////////// FIR //////////


wire [1:0]  ast_sink_error = 2'b00;
output reg[32:0] ast_source_data;
output reg [32:0] DFF_ast_source_data;
output reg  ast_source_valid;
reg  l_ast_source_valid;
output reg  [1:0]  ast_source_error;
reg [4:0]  coeff_in_address;
reg        coeff_in_areset=1'b0;
reg        coeff_in_read = 1'b0;
reg [0:0]  coeff_out_valid;
reg [15:0] coeff_out_data;
reg [0:0]  coeff_in_we=1'b0;
reg [15:0] coeff_in_data;
reg [15:0] mem [0:31];
reg [15:0] mem1 [0:31];
reg [1:0] state_f = 2'd0;
wire sw_17_debounced;
parameter IDLE  = 2'd0,COUNT_ON = 2'd1,WRITE_COEFF = 2'd2;
reg switch_prev = 0;
reg [5:0] i = 6'd0;
reg ast_sink_valid;


initial begin
mem[0]	=	-	16'sd	1	;
mem[1]	=		16'sd	63	;
mem[2]	=	-	16'sd	89	;
mem[3]	=		16'sd	3	;
mem[4]	=		16'sd	227	;
mem[5]	=	-	16'sd	435	;
mem[6]	=		16'sd	301	;
mem[7]	=		16'sd	349	;
mem[8]	=	-	16'sd	1202	;
mem[9]	=		16'sd	1430	;
mem[10]	=	-	16'sd	247	;
mem[11]	=	-	16'sd	2235	;
mem[12]	=		16'sd	4504	;
mem[13]	=	-	16'sd	3920	;
mem[14]	=	-	16'sd	3006	;
mem[15]	=		16'sd	32767	;
mem[16]	=		16'sd	32767	;
mem[17]	=	-	16'sd	3006	;
mem[18]	=	-	16'sd	3920	;
mem[19]	=		16'sd	4504	;
mem[20]	=	-	16'sd	2235	;
mem[21]	=	-	16'sd	247	;
mem[22]	=		16'sd	1430	;
mem[23]	=	-	16'sd	1202	;
mem[24]	=		16'sd	349	;
mem[25]	=		16'sd	301	;
mem[26]	=	-	16'sd	435	;
mem[27]	=		16'sd	227	;
mem[28]	=		16'sd	3	;
mem[29]	=	-	16'sd	89	;
mem[30]	=		16'sd	63	;
mem[31]	=	-	16'sd	1	;

mem1[0]	=		16'sd	309	;
mem1[1]	=	-	16'sd	226	;
mem1[2]	=	-	16'sd	47	;
mem1[3]	=	-	16'sd	349	;
mem1[4]	=	-	16'sd	1037	;
mem1[5]	=		16'sd	1932	;
mem1[6]	=		16'sd	2737	;
mem1[7]	=	-	16'sd	2959	;
mem1[8]	=	-	16'sd	2021	;
mem1[9]	=	-	16'sd	556	;
mem1[10]	=	-	16'sd	4962	;
mem1[11]	=		16'sd	10950	;
mem1[12]	=		16'sd	17813	;
mem1[13]	=	-	16'sd	24493	;
mem1[14]	=	-	16'sd	29815	;
mem1[15]	=		16'sd	32767	;
mem1[16]	=		16'sd	32767	;
mem1[17]	=	-	16'sd	29815	;
mem1[18]	=	-	16'sd	24493	;
mem1[19]	=		16'sd	17813	;
mem1[20]	=		16'sd	10950	;
mem1[21]	=	-	16'sd	4962	;
mem1[22]	=	-	16'sd	556	;
mem1[23]	=	-	16'sd	2021	;
mem1[24]	=	-	16'sd	2959	;
mem1[25]	=		16'sd	2737	;
mem1[26]	=		16'sd	1932	;
mem1[27]	=	-	16'sd	1037	;
mem1[28]	=	-	16'sd	349	;
mem1[29]	=	-	16'sd	47	;
mem1[30]	=	-	16'sd	226	;
mem1[31]	=		16'sd	309	;


end


//=======================================================
//  Structural coding
//=======================================================

//--- globa signal assign
assign	reset_n			= KEY[3];
assign	NCO_FREQ_UP			= KEY[2];
assign	NCO_FREQ_DOWN			= KEY[1];
assign	FPGA_CLK_A_P	=  sys_clk;
assign	FPGA_CLK_A_N	= ~sys_clk;

 // assign for ADC control signal
assign	AD_SCLK			= SW[0];			// (DFS)Data Format Select
assign	AD_SDIO			= SW[1];			// (DCS)Duty Cycle Stabilizer Select
assign	ADA_OE			= 1'b0;				// enable ADA output
assign	ADA_SPI_CS		= 1'b1;				// disable ADA_SPI_CS (CSB)


//--- analog to digital converter capture and sync
	//--- Channel A
always @(negedge reset_n or posedge ADA_DCO)
begin
	if (!reset_n) begin
		per_a2da_d	<= 14'd0;
	end
	else begin
		per_a2da_d	<= ADA_D;
	end
end

always @(negedge reset_n or posedge sys_clk)
begin
	if (!reset_n) begin
		a2da_data	<= 14'd0;
	end
	else begin
		a2da_data	<= per_a2da_d;
	end
end


//--- probe points for data capture
a2d_data_a	a2d_data_a_inst(
			.probe(a2da_data),
			.source());

nco abc_inst (.clk			(CLOCK_50),
			.phase_incr (NCO_IN),
			.cos_out  (NCO_OUT));
			
PLL_200MHz PLL_200MHz_inst (.inclk0(CLOCK_50),
				.c0(CLOCK_200),
				.locked());			
	
always @(posedge CLOCK_50)
begin
	if (counter == 16'd2500)
	begin
	clk_1khz <= ~clk_1khz;
	counter <= 16'd0;
	end
	else 
	begin
	counter = counter +1;	
	end	
end

always @( posedge clk_1khz)
begin
	if ((NCO_FREQ_UP ==1) && (NCO_FREQ_DOWN ==0))
	begin 
	temp= temp + 1;
	end
	
	if ((NCO_FREQ_DOWN ==1) && (NCO_FREQ_UP ==0))
	begin 
	temp= temp - 1;
	end
end 

/*
fir_IP_0002 fir_ip_inst (
		.clk              (CLOCK_50),              //                     clk.clk
		.reset_n          (reset_n),          //                     rst.reset_n
		.ast_sink_data    (NCO_OUT),    //   avalon_streaming_sink.data
		.ast_sink_valid   (1'b1),   //                        .valid
		.ast_sink_error   (ast_sink_error),   //                        .error
		.ast_source_data  (ast_source_data),  // avalon_streaming_source.data
		.ast_source_valid (ast_source_valid), //                        .valid
		.ast_source_error (ast_source_error)  //                        .error
	);
*/
	
	fir_IP_0002 fir_ip_inst (
		.clk              (CLOCK_200),              //                     clk.clk
		.reset_n          (reset_n),          //                     rst.reset_n
		.ast_sink_data    (l_NCO_OUT),    //   avalon_streaming_sink.data
		.ast_sink_valid   (ast_sink_valid),   //                        .valid
		.ast_sink_error   (ast_sink_error),   //                        .error
		.ast_source_data  (ast_source_data),  // avalon_streaming_source.data
		.ast_source_valid (ast_source_valid), //                        .valid
		.ast_source_error (ast_source_error),
		//                        .error
		.coeff_in_clk     (CLOCK_200),     //             coeff_clock.clk
		.coeff_in_areset  (coeff_in_areset),  //             coeff_reset.reset_n
		.coeff_in_address (coeff_in_address), //         avalon_mm_slave.address
		.coeff_in_read    (coeff_in_read),    //                        .read
		.coeff_out_valid  (coeff_out_valid),  //                        .readdatavalid
		.coeff_out_data   (coeff_out_data),   //                        .readdata
		.coeff_in_we      (coeff_in_we),      //                        .write
		.coeff_in_data    (coeff_in_data)     //                        .writedata
	);

	
/*
	always @ (filter_change_sw)
begin 
	if ((filter_change_sw ==1) && (switch_prev ==0))
	begin
	
	switch_prev <=1;
	coeff_in_areset <=1'b1;

	temp_b <= 1'b0;
	temp_a <= temp_b;
	coeff_in_areset <= temp_a;
	
	for (i=5'd0; i<5'd32 ; i=i+1)
	begin
		coeff_in_we <= 1'b1;
		coeff_in_address <= i;
		coeff_in_data <= mem[i];
		
	end
	coeff_in_we <= 1'b0;
	end
	

	if ((filter_change_sw ==0) && (switch_prev ==1))
	begin

	switch_prev <=0;
	coeff_in_areset <=1'b1;

	temp_b <= 1'b0;
	temp_a <= temp_b;
	coeff_in_areset <= temp_a;
	
	for (i=5'd0; i<5'd32 ; i=i+1)
	begin
		coeff_in_we <= 1'b1;
		coeff_in_address <= i;
		coeff_in_data <= mem1[i];
		
	end
	coeff_in_we <= 1'b0;
	end
end	*/

// Adding debouncer
debouncer debounce_sw17 (.clk (CLOCK_50), 
						  	    .i (filter_change_sw), 
						  		 .o (sw_17_debounced));

								 
// State machine for coeff reload
always @(posedge CLOCK_200) begin

case (state_f)

IDLE:begin

	if (sw_17_debounced != switch_prev)  begin
	switch_prev <=sw_17_debounced;
	coeff_in_areset <=1'b1;
	state_f <= COUNT_ON;
	async_counter <= 6'd0;			
	end
end
	
COUNT_ON: begin
	if (async_counter != 6'd1) begin
	async_counter = async_counter +1;
	end
	else begin
	i <= 6'd0;
	state_f <= WRITE_COEFF;
	coeff_in_areset <= 1'b0;
	end
	end

WRITE_COEFF: 
begin
	if ( i < 6'd32)
	begin
	
		coeff_in_we <= 1'b1;
	
		if (sw_17_debounced == 0) 
			begin
			coeff_in_address <= i;
			coeff_in_data <= mem[i];
			i <=i +1;
			end
		else 	
			begin
			coeff_in_address <= i;
			coeff_in_data <= mem1[i];
			i <=i +1;
		end
	end
	else 
		begin
		coeff_in_we <= 1'b0;
		state_f <= IDLE;
		end
end


default : state_f <= IDLE;

endcase
end

// to latch the filter's output; confine only to valid values
always @(posedge CLOCK_200) begin
l_ast_source_valid <= ast_source_valid;
DFF_ast_source_data <= DFF_ast_source_data;
	if ((l_ast_source_valid == 0) && (ast_source_valid == 1)) begin
	DFF_ast_source_data <= ast_source_data;
	end
end 

//to take care of sink_valid generation and latching NCO's o/p
always @(posedge CLOCK_200) begin
	l_CLOCK_50 <= CLOCK_50;
	ll_CLOCK_50 <= l_CLOCK_50;
	lll_CLOCK_50 <= ll_CLOCK_50;
	ast_sink_valid <= 1'b0;
	//l_NCO_OUT <=l_NCO_OUT;
	if ((lll_CLOCK_50 ==0) && (ll_CLOCK_50 ==1)) begin
		l_NCO_OUT <=NCO_OUT;
		ast_sink_valid <= 1'b1;
	end
end


endmodule
